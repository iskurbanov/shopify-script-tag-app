{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nclass UrlNode {\n  constructor() {\n    this.placeholder = true;\n    this.children = new Map();\n    this.slugName = null;\n    this.restSlugName = null;\n  }\n\n  insert(urlPath) {\n    this._insert(urlPath.split('/').filter(Boolean), [], false);\n  }\n\n  smoosh() {\n    return this._smoosh();\n  }\n\n  _smoosh(prefix = '/') {\n    const childrenPaths = [...this.children.keys()].sort();\n\n    if (this.slugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[]'), 1);\n    }\n\n    if (this.restSlugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[...]'), 1);\n    }\n\n    const routes = childrenPaths.map(c => this.children.get(c)._smoosh(`${prefix}${c}/`)).reduce((prev, curr) => [...prev, ...curr], []);\n\n    if (this.slugName !== null) {\n      routes.push(...this.children.get('[]')._smoosh(`${prefix}[${this.slugName}]/`));\n    }\n\n    if (!this.placeholder) {\n      routes.unshift(prefix === '/' ? '/' : prefix.slice(0, -1));\n    }\n\n    if (this.restSlugName !== null) {\n      routes.push(...this.children.get('[...]')._smoosh(`${prefix}[...${this.restSlugName}]/`));\n    }\n\n    return routes;\n  }\n\n  _insert(urlPaths, slugNames, isCatchAll) {\n    if (urlPaths.length === 0) {\n      this.placeholder = false;\n      return;\n    }\n\n    if (isCatchAll) {\n      throw new Error(`Catch-all must be the last part of the URL.`);\n    } // The next segment in the urlPaths list\n\n\n    let nextSegment = urlPaths[0]; // Check if the segment matches `[something]`\n\n    if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {\n      // Strip `[` and `]`, leaving only `something`\n      let segmentName = nextSegment.slice(1, -1);\n\n      if (segmentName.startsWith('...')) {\n        segmentName = segmentName.substring(3);\n        isCatchAll = true;\n      }\n\n      if (segmentName.startsWith('.')) {\n        throw new Error(`Segment names may not start with erroneous periods ('${segmentName}').`);\n      }\n\n      function handleSlug(previousSlug, nextSlug) {\n        if (previousSlug !== null) {\n          // If the specific segment already has a slug but the slug is not `something`\n          // This prevents collisions like:\n          // pages/[post]/index.js\n          // pages/[id]/index.js\n          // Because currently multiple dynamic params on the same segment level are not supported\n          if (previousSlug !== nextSlug) {\n            // TODO: This error seems to be confusing for users, needs an err.sh link, the description can be based on above comment.\n            throw new Error(`You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`);\n          }\n        }\n\n        if (slugNames.indexOf(nextSlug) !== -1) {\n          throw new Error(`You cannot have the same slug name \"${nextSlug}\" repeat within a single dynamic path`);\n        }\n\n        slugNames.push(nextSlug);\n      }\n\n      if (isCatchAll) {\n        handleSlug(this.restSlugName, segmentName); // slugName is kept as it can only be one particular slugName\n\n        this.restSlugName = segmentName; // nextSegment is overwritten to [] so that it can later be sorted specifically\n\n        nextSegment = '[...]';\n      } else {\n        handleSlug(this.slugName, segmentName); // slugName is kept as it can only be one particular slugName\n\n        this.slugName = segmentName; // nextSegment is overwritten to [] so that it can later be sorted specifically\n\n        nextSegment = '[]';\n      }\n    } // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n\n\n    if (!this.children.has(nextSegment)) {\n      this.children.set(nextSegment, new UrlNode());\n    }\n\n    this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n  }\n\n}\n\nfunction getSortedRoutes(normalizedPages) {\n  // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n  // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n  // Only 1 dynamic segment per nesting level\n  // So in the case that is test/integration/dynamic-routing it'll be this:\n  // pages/[post]/comments.js\n  // pages/blog/[post]/comment/[id].js\n  // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n  // So in this case `UrlNode` created here has `this.slugName === 'post'`\n  // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n  // Instead what has to be passed through is the upwards path's dynamic names\n  const root = new UrlNode(); // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n\n  normalizedPages.forEach(pagePath => root.insert(pagePath)); // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n\n  return root.smoosh();\n}\n\nexports.getSortedRoutes = getSortedRoutes;","map":{"version":3,"sources":["/Users/iskandarkurbanov/Desktop/script-tag-app/node_modules/next/dist/next-server/lib/router/utils/sorted-routes.js"],"names":["Object","defineProperty","exports","value","UrlNode","constructor","placeholder","children","Map","slugName","restSlugName","insert","urlPath","_insert","split","filter","Boolean","smoosh","_smoosh","prefix","childrenPaths","keys","sort","splice","indexOf","routes","map","c","get","reduce","prev","curr","push","unshift","slice","urlPaths","slugNames","isCatchAll","length","Error","nextSegment","startsWith","endsWith","segmentName","substring","handleSlug","previousSlug","nextSlug","has","set","getSortedRoutes","normalizedPages","root","forEach","pagePath"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass UrlNode {\n    constructor() {\n        this.placeholder = true;\n        this.children = new Map();\n        this.slugName = null;\n        this.restSlugName = null;\n    }\n    insert(urlPath) {\n        this._insert(urlPath.split('/').filter(Boolean), [], false);\n    }\n    smoosh() {\n        return this._smoosh();\n    }\n    _smoosh(prefix = '/') {\n        const childrenPaths = [...this.children.keys()].sort();\n        if (this.slugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf('[]'), 1);\n        }\n        if (this.restSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf('[...]'), 1);\n        }\n        const routes = childrenPaths\n            .map(c => this.children.get(c)._smoosh(`${prefix}${c}/`))\n            .reduce((prev, curr) => [...prev, ...curr], []);\n        if (this.slugName !== null) {\n            routes.push(...this.children.get('[]')._smoosh(`${prefix}[${this.slugName}]/`));\n        }\n        if (!this.placeholder) {\n            routes.unshift(prefix === '/' ? '/' : prefix.slice(0, -1));\n        }\n        if (this.restSlugName !== null) {\n            routes.push(...this.children\n                .get('[...]')\n                ._smoosh(`${prefix}[...${this.restSlugName}]/`));\n        }\n        return routes;\n    }\n    _insert(urlPaths, slugNames, isCatchAll) {\n        if (urlPaths.length === 0) {\n            this.placeholder = false;\n            return;\n        }\n        if (isCatchAll) {\n            throw new Error(`Catch-all must be the last part of the URL.`);\n        }\n        // The next segment in the urlPaths list\n        let nextSegment = urlPaths[0];\n        // Check if the segment matches `[something]`\n        if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {\n            // Strip `[` and `]`, leaving only `something`\n            let segmentName = nextSegment.slice(1, -1);\n            if (segmentName.startsWith('...')) {\n                segmentName = segmentName.substring(3);\n                isCatchAll = true;\n            }\n            if (segmentName.startsWith('.')) {\n                throw new Error(`Segment names may not start with erroneous periods ('${segmentName}').`);\n            }\n            function handleSlug(previousSlug, nextSlug) {\n                if (previousSlug !== null) {\n                    // If the specific segment already has a slug but the slug is not `something`\n                    // This prevents collisions like:\n                    // pages/[post]/index.js\n                    // pages/[id]/index.js\n                    // Because currently multiple dynamic params on the same segment level are not supported\n                    if (previousSlug !== nextSlug) {\n                        // TODO: This error seems to be confusing for users, needs an err.sh link, the description can be based on above comment.\n                        throw new Error(`You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`);\n                    }\n                }\n                if (slugNames.indexOf(nextSlug) !== -1) {\n                    throw new Error(`You cannot have the same slug name \"${nextSlug}\" repeat within a single dynamic path`);\n                }\n                slugNames.push(nextSlug);\n            }\n            if (isCatchAll) {\n                handleSlug(this.restSlugName, segmentName);\n                // slugName is kept as it can only be one particular slugName\n                this.restSlugName = segmentName;\n                // nextSegment is overwritten to [] so that it can later be sorted specifically\n                nextSegment = '[...]';\n            }\n            else {\n                handleSlug(this.slugName, segmentName);\n                // slugName is kept as it can only be one particular slugName\n                this.slugName = segmentName;\n                // nextSegment is overwritten to [] so that it can later be sorted specifically\n                nextSegment = '[]';\n            }\n        }\n        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n        if (!this.children.has(nextSegment)) {\n            this.children.set(nextSegment, new UrlNode());\n        }\n        this.children\n            .get(nextSegment)\n            ._insert(urlPaths.slice(1), slugNames, isCatchAll);\n    }\n}\nfunction getSortedRoutes(normalizedPages) {\n    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n    // Only 1 dynamic segment per nesting level\n    // So in the case that is test/integration/dynamic-routing it'll be this:\n    // pages/[post]/comments.js\n    // pages/blog/[post]/comment/[id].js\n    // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n    // So in this case `UrlNode` created here has `this.slugName === 'post'`\n    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n    // Instead what has to be passed through is the upwards path's dynamic names\n    const root = new UrlNode();\n    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n    normalizedPages.forEach(pagePath => root.insert(pagePath));\n    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n    return root.smoosh();\n}\nexports.getSortedRoutes = getSortedRoutes;\n"]},"metadata":{},"sourceType":"script"}